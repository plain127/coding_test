# <성적이 낮은 순서로 학생 출력하기>

## 내가 푼 풀이

#### 이 코드는 dic라는 딕셔너리를 사용하여 성적을 키로, 이름을 값으로 저장합니다.

#### 하지만 이 접근법은 동일한 성적을 가진 학생이 여러 명 있는 경우 문제가 발생할 수 있습니다. 딕셔너리는 키의 중복을 허용하지 않기 때문에, 마지막에 입력된 학생의 정보만 저장되고 이전에 동일한 성적을 가진 학생의 정보는 덮어씌워집니다.

#### 성적을 리스트에 추가한 후 정렬하는 방법은 올바르지만, 성적이 문자열로 처리되므로 정수 변환 없이 정렬할 경우 예상치 못한 정렬 결과를 얻을 수 있습니다(예: '100'이 '2'보다 앞에 오는 문제).

#### 코드의 효율성과 정확성 측면에서 개선이 필요합니다.

## 책 풀이

#### 이 코드는 학생의 이름과 성적을 하나의 리스트로 묶어 array 리스트에 저장합니다. 이 방식은 동일한 성적을 가진 학생이 여러 명 있어도 각각의 학생 정보를 개별적으로 관리할 수 있게 합니다.

#### 성적에 따라 정렬할 때, lambda 함수를 사용하여 리스트의 두 번째 요소(성적)를 기준으로 정렬합니다. 이는 정확한 성적 순 정렬을 가능하게 하며, 성적이 정수로 처리되어 정확한 비교가 이루어집니다.

#### 코드의 접근 방식은 데이터의 정확성을 유지하고, 중복된 성적을 가진 학생들도 올바르게 처리할 수 있습니다.

## 결론

#### 책에서 제시한 풀이가 더 효율적이고 잘 만들어진 코드입니다. 이유는 다음과 같습니다:

### 정확성: 동일한 성적을 가진 학생들을 모두 처리할 수 있습니다.

### 효율성: 성적을 기준으로 정렬할 때, lambda 함수를 사용하여 성적이 정수로 처리되어 정확하게 정렬됩니다.

### 유연성: 새로운 학생 정보가 추가되거나 변경되어도 쉽게 코드를 수정할 수 있는 구조를 가지고 있습니다.

### 따라서, 데이터의 정확한 처리와 효율적인 관리 측면에서 책의 풀이 방식이 더 우수합니다.

</br>
</br>
</br>

# <두 배열의 원소 교체>

## 내가 푼 풀이

#### 정렬: 배열 A와 B를 오름차순으로 정렬합니다.

#### 교환 과정: K번의 교환을 시도합니다. 배열 A의 최소값과 배열 B의 최대값을 비교하여, A의 값이 더 작을 경우 교환합니다. B에서 최대값을 선택하기 위해 n-i-1 인덱스를 사용합니다.

#### 합계 계산: 배열 A의 모든 요소의 합을 계산합니다.

### 이 접근법은 명확하고 직관적이며, 문제의 요구사항을 충족합니다. 하지만, 배열 B를 오름차순으로 정렬한 후 인덱스 계산을 통해 최대값을 찾는 것은 다소 간접적인 방법입니다.

## 책 풀이

#### 정렬: 배열 A는 오름차순으로, 배열 B는 내림차순으로 정렬합니다. 이렇게 함으로써, 각 배열에서 교환될 요소를 직접적으로 인덱스로 접근할 수 있게 됩니다.

#### 교환 과정: K번의 교환을 시도합니다. 배열 A의 최소값과 배열 B의 최대값(내림차순 정렬되어 있으므로 첫 번째 요소)을 비교하여, A의 값이 더 작을 경우 교환합니다. 이 과정은 더 직관적이며, 인덱스 계산을 간소화합니다.

#### 합계 계산: sum(a)를 사용하여 배열 A의 모든 요소의 합을 계산합니다. 이는 파이썬의 내장 함수를 활용하는 간결하고 효율적인 방법입니다.

### 결론

#### 책에서 제시한 풀이 방법이 더 효율적입니다. 주된 이유는 다음과 같습니다:

### 간결성: 코드가 더 간결하며, 파이썬의 내장 함수를 효과적으로 활용합니다(sum(a)).

### 직관성: 배열 B를 내림차순으로 정렬함으로써, 교환 과정에서의 인덱스 접근을 간소화하고 더 직관적으로 만듭니다.

### 성능: 성능 측면에서 두 코드는 유사할 수 있지만, 책의 풀이는 읽기 쉽고 이해하기 쉬운 코드 스타일을 제공합니다.

### 코드의 간결성과 가독성은 유지보수와 코드의 이해를 용이하게 하므로 중요한 요소입니다. 따라서, 책의 풀이 방식이 더 우수한 접근법으로 평가됩니다.
